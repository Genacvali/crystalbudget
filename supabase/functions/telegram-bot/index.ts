import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const TELEGRAM_BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN');
const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

const supabase = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!);

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –∫ —Ä—É–±–ª—é (–º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ API)
const exchangeRates: Record<string, number> = {
  RUB: 1,
  USD: 0.01, // 1 USD = 100 RUB
  EUR: 0.011, // 1 EUR = 90 RUB
  GBP: 0.012, // 1 GBP = 85 RUB
  JPY: 0.067, // 1 JPY = 15 RUB
  CNY: 0.014, // 1 CNY = 70 RUB
  KRW: 0.0075, // 1 KRW = 130 RUB
  GEL: 0.033, // 1 GEL = 30 RUB
  AMD: 0.025, // 1 AMD = 40 RUB
};

// Currency symbols mapping
const currencySymbols: Record<string, string> = {
  RUB: '‚ÇΩ',
  USD: '$',
  EUR: '‚Ç¨',
  GBP: '¬£',
  JPY: '¬•',
  CNY: '¬•',
  KRW: '‚Ç©',
  GEL: '‚Çæ',
  AMD: '÷è',
};

interface TelegramMessage {
  message_id: number;
  from: {
    id: number;
    first_name: string;
    last_name?: string;
    username?: string;
  };
  chat: {
    id: number;
  };
  text?: string;
  photo?: Array<{
    file_id: string;
    file_unique_id: string;
    file_size: number;
    width: number;
    height: number;
  }>;
  caption?: string;
}

interface CallbackQuery {
  id: string;
  from: {
    id: number;
    first_name: string;
  };
  message?: TelegramMessage;
  data?: string;
}

interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
  callback_query?: CallbackQuery;
}

// User session storage for multi-step operations (now in database)
async function getSession(telegramId: number) {
  const { data, error } = await supabase
    .from('telegram_bot_sessions')
    .select('session_data')
    .eq('telegram_id', telegramId)
    .gt('expires_at', new Date().toISOString())
    .maybeSingle();

  if (error) {
    console.error('Error getting session:', error);
    return null;
  }

  return data?.session_data || null;
}

async function setSession(telegramId: number, sessionData: any) {
  const { error } = await supabase
    .from('telegram_bot_sessions')
    .upsert({
      telegram_id: telegramId,
      session_data: sessionData,
      expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString(), // 1 hour
    });

  if (error) {
    console.error('Error setting session:', error);
  }
}

async function deleteSession(telegramId: number) {
  await supabase
    .from('telegram_bot_sessions')
    .delete()
    .eq('telegram_id', telegramId);
}

async function sendTelegramMessage(chatId: number, text: string, keyboard?: any) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
  const body: any = {
    chat_id: chatId,
    text: text,
    parse_mode: 'HTML',
  };

  if (keyboard) {
    body.reply_markup = keyboard;
  }

  console.log(`Sending message to ${chatId}, has keyboard: ${!!keyboard}`);

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error(`Telegram API error: ${JSON.stringify(result)}`);
    } else {
      console.log(`Message sent successfully`);
    }

    return result;
  } catch (error) {
    console.error(`Error sending message: ${error}`);
    throw error;
  }
}

async function answerCallbackQuery(callbackQueryId: string, text?: string) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/answerCallbackQuery`;
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        callback_query_id: callbackQueryId,
        text: text,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error(`answerCallbackQuery failed: ${JSON.stringify(result)}`);
    } else {
      console.log(`answerCallbackQuery success for ${callbackQueryId}`);
    }

    return result;
  } catch (error) {
    console.error(`Error in answerCallbackQuery: ${error}`);
    throw error;
  }
}

async function getUserByTelegramId(telegramId: number) {
  const { data, error } = await supabase
    .from('telegram_users')
    .select('user_id')
    .eq('telegram_id', telegramId)
    .maybeSingle();

  if (error) {
    console.error('Error fetching user:', error);
    return null;
  }

  return data?.user_id || null;
}

async function getUserCurrency(userId: string): Promise<string> {
  const { data, error } = await supabase
    .from('user_preferences')
    .select('currency')
    .eq('user_id', userId)
    .maybeSingle();

  if (error) {
    console.error('Error fetching user currency:', error);
    return 'RUB'; // Default currency
  }

  return data?.currency || 'RUB';
}

function formatAmount(amountInRubles: number, currency: string): string {
  const rate = exchangeRates[currency] || 1;
  const convertedAmount = amountInRubles * rate;
  const symbol = currencySymbols[currency] || '‚ÇΩ';
  return `${convertedAmount.toLocaleString('ru-RU')} ${symbol}`;
}

// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≤–∞–ª—é—Ç—ã –≤ —Ä—É–±–ª–∏
function convertToRubles(amount: number, currency: string): number {
  const rate = exchangeRates[currency] || 1;
  return amount / rate;
}

async function hasActiveSubscription(userId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .gt('expires_at', new Date().toISOString())
    .maybeSingle();

  if (error) {
    console.error('Error checking subscription:', error);
    return false;
  }

  return !!data;
}

async function getSubscriptionInfo(userId: string) {
  const { data, error } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .gt('expires_at', new Date().toISOString())
    .maybeSingle();

  if (error) {
    console.error('Error getting subscription:', error);
    return null;
  }

  return data;
}

function getMainKeyboard() {
  return {
    keyboard: [
      [{ text: 'üí∞ –§–∏–Ω–∞–Ω—Å—ã' }],
      [{ text: '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏' }]
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
}

function getFinanceKeyboard() {
  return {
    keyboard: [
      [{ text: 'üí∏ –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥' }, { text: 'üí∞ –î–æ–±–∞–≤–∏—Ç—å –¥–æ—Ö–æ–¥' }],
      [{ text: 'üì∏ –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —á–µ–∫' }],
      [{ text: 'üîô –ù–∞–∑–∞–¥' }]
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
}

function getReportsKeyboard() {
  return {
    keyboard: [
      [{ text: 'üìä –ë–∞–ª–∞–Ω—Å' }],
      [{ text: 'üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏' }, { text: 'üíµ –ò—Å—Ç–æ—á–Ω–∏–∫–∏' }],
      [{ text: 'üîô –ù–∞–∑–∞–¥' }]
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
}

function getSettingsKeyboard() {
  return {
    keyboard: [
      [{ text: 'üåç –í–∞–ª—é—Ç–∞' }],
      [{ text: '‚ùì –ü–æ–º–æ—â—å' }],
      [{ text: 'üîô –ù–∞–∑–∞–¥' }]
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
}

function getCurrencyKeyboard() {
  // Supported currencies should match user_preferences.currency values
  const codes = ['RUB','USD','EUR','GBP','JPY','CNY','KRW','GEL','AMD'];
  // Build inline keyboard in 3 columns
  const rows: any[] = [];
  for (let i = 0; i < codes.length; i += 3) {
    rows.push(
      codes.slice(i, i + 3).map((code) => ({ text: `${currencySymbols[code] || ''} ${code}`, callback_data: `currency_${code}` }))
    );
  }
  // Use dedicated back callback for currency menu
  rows.push([{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'currency_back' }]);
  return { inline_keyboard: rows };
}

async function generateCloudPaymentsLink(userId: string, planType: string, amount: number, email?: string): Promise<string> {
  const CLOUDPAYMENTS_PUBLIC_ID = Deno.env.get('CLOUDPAYMENTS_PUBLIC_ID');

  const orderId = `sub_${userId}_${planType}_${Date.now()}`;

  // Store payment info in session for webhook validation
  await supabase.from('telegram_bot_sessions').upsert({
    telegram_id: 0, // Using 0 as placeholder for payment sessions
    session_data: {
      type: 'payment_pending',
      orderId,
      userId,
      planType,
      amount
    },
    expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24 hours
  }, {
    onConflict: 'telegram_id'
  });

  // Create CloudPayments widget URL
  const paymentUrl = `https://widget.cloudpayments.ru/pay?publicId=${CLOUDPAYMENTS_PUBLIC_ID}&description=–ü–æ–¥–ø–∏—Å–∫–∞ CrystalBudget&amount=${amount}&currency=RUB&accountId=${userId}&invoiceId=${orderId}&email=${email || ''}`;

  return paymentUrl;
}

async function handleStart(chatId: number, telegramId: number, firstName: string, lastName?: string, username?: string) {
  // Check if already linked
  const userId = await getUserByTelegramId(telegramId);

  if (userId) {
    await sendTelegramMessage(
      chatId,
      `üëã –ü—Ä–∏–≤–µ—Ç, ${firstName}!\n\n` +
      `–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —Å–≤—è–∑–∞–Ω —Å CrystalBudget.\n` +
      `–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±—é–¥–∂–µ—Ç–æ–º.\n\n` +
      `üí° –ù–∞–∂–º–∏—Ç–µ ‚ùì –ü–æ–º–æ—â—å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π.`,
      getMainKeyboard()
    );
    return;
  }

  // Generate auth code
  const authCode = Math.random().toString(36).substring(2, 10).toUpperCase();

  const { error } = await supabase
    .from('telegram_auth_codes')
    .insert({
      telegram_id: telegramId,
      auth_code: authCode,
      telegram_username: username,
      telegram_first_name: firstName,
      telegram_last_name: lastName,
    });

  if (error) {
    console.error('Error creating auth code:', error);
    await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–¥–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    return;
  }

  await sendTelegramMessage(
    chatId,
    `üëã –ü—Ä–∏–≤–µ—Ç, ${firstName}!\n\n` +
    `üîê –í–∞—à –∫–æ–¥ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:\n<code>${authCode}</code>\n\n` +
    `üì± –í–≤–µ–¥–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget.\n\n` +
    `‚è± –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 10 –º–∏–Ω—É—Ç.`
  );
}

async function handleBalance(chatId: number, userId: string) {
  // Get user currency
  const currency = await getUserCurrency(userId);

  // Check if user has a family
  const { data: familyMember } = await supabase
    .from('family_members')
    .select('family_id')
    .eq('user_id', userId)
    .maybeSingle();

  // Get current month boundaries
  const now = new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();
  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59).toISOString();

  // Get all family members if user has a family
  let familyUserIds = [userId];
  if (familyMember) {
    const { data: familyMembers } = await supabase
      .from('family_members')
      .select('user_id')
      .eq('family_id', familyMember.family_id);

    if (familyMembers) {
      familyUserIds = familyMembers.map(m => m.user_id);
    }
  }

  // Get current month income and expenses (for all family members)
  const { data: incomes } = await supabase
    .from('incomes')
    .select('amount')
    .in('user_id', familyUserIds)
    .gte('date', startOfMonth)
    .lte('date', endOfMonth);

  const { data: expenses } = await supabase
    .from('expenses')
    .select('amount')
    .in('user_id', familyUserIds)
    .gte('date', startOfMonth)
    .lte('date', endOfMonth);

  // Get previous months for carry-over balance (for all family members)
  const { data: previousIncomes } = await supabase
    .from('incomes')
    .select('amount')
    .in('user_id', familyUserIds)
    .lt('date', startOfMonth);

  const { data: previousExpenses } = await supabase
    .from('expenses')
    .select('amount')
    .in('user_id', familyUserIds)
    .lt('date', startOfMonth);

  const currentMonthIncome = (incomes || []).reduce((sum, inc) => sum + Number(inc.amount), 0);
  const currentMonthExpenses = (expenses || []).reduce((sum, exp) => sum + Number(exp.amount), 0);
  const monthBalance = currentMonthIncome - currentMonthExpenses;

  const previousTotalIncome = (previousIncomes || []).reduce((sum, inc) => sum + Number(inc.amount), 0);
  const previousTotalExpenses = (previousExpenses || []).reduce((sum, exp) => sum + Number(exp.amount), 0);
  const carryOverBalance = previousTotalIncome - previousTotalExpenses;

  const totalBalance = monthBalance + carryOverBalance;

  const monthName = new Intl.DateTimeFormat('ru-RU', { month: 'long', year: 'numeric' }).format(now);

  await sendTelegramMessage(
    chatId,
    `üìä <b>–ë–∞–ª–∞–Ω—Å –∑–∞ ${monthName.charAt(0).toUpperCase() + monthName.slice(1)}</b>\n` +
    `${monthBalance > 0 ? '‚úÖ' : monthBalance < 0 ? '‚ùå' : '‚ûñ'} <b>${formatAmount(monthBalance, currency)}</b>\n` +
    `${monthBalance > 0 ? '–ü—Ä–æ—Ñ–∏—Ü–∏—Ç' : monthBalance < 0 ? '–î–µ—Ñ–∏—Ü–∏—Ç' : '–ù–æ–ª—å'}\n\n` +
    `üìâ <b>–û–±—â–∏–µ —Ä–∞—Å—Ö–æ–¥—ã</b>\n` +
    `<b>${formatAmount(currentMonthExpenses, currency)}</b>\n` +
    (currentMonthIncome > 0 ? `${Math.round(currentMonthExpenses / currentMonthIncome * 100)}% –æ—Ç –¥–æ—Ö–æ–¥–∞\n\n` : '\n') +
    `üí∞ <b>–û–±—â–∏–π –±–∞–ª–∞–Ω—Å</b>\n` +
    `<b>${formatAmount(totalBalance, currency)}</b>\n` +
    (carryOverBalance !== 0 ? `${formatAmount(monthBalance, currency)} + ${formatAmount(carryOverBalance, currency)} –æ—Å—Ç–∞—Ç–æ–∫` : `–¢–æ–ª—å–∫–æ –∑–∞ ${monthName}`),
    getMainKeyboard()
  );
}

async function handleCategories(chatId: number, userId: string) {
  const { data: categories } = await supabase
    .from('categories')
    .select('name, icon')
    .eq('user_id', userId)
    .order('name');

  if (!categories || categories.length === 0) {
    await sendTelegramMessage(
      chatId,
      'üìÅ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ä–∞—Å—Ö–æ–¥–æ–≤.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget.',
      getMainKeyboard()
    );
    return;
  }

  const categoryList = categories
    .map(cat => `${cat.icon} ${cat.name}`)
    .join('\n');

  await sendTelegramMessage(
    chatId,
    `üìÅ <b>–í–∞—à–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (${categories.length}):</b>\n\n${categoryList}`,
    getMainKeyboard()
  );
}

async function handleSources(chatId: number, userId: string) {
  // Get user currency
  const currency = await getUserCurrency(userId);

  const { data: sources } = await supabase
    .from('income_sources')
    .select('name, color, amount')
    .eq('user_id', userId)
    .order('name');

  if (!sources || sources.length === 0) {
    await sendTelegramMessage(
      chatId,
      'üíµ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–æ—Ö–æ–¥–∞.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget.',
      getMainKeyboard()
    );
    return;
  }

  const sourceList = sources
    .map(src => {
      const amount = src.amount ? ` (${formatAmount(Number(src.amount), currency)})` : '';
      return `üíµ ${src.name}${amount}`;
    })
    .join('\n');

  await sendTelegramMessage(
    chatId,
    `üíµ <b>–í–∞—à–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–æ—Ö–æ–¥–∞ (${sources.length}):</b>\n\n${sourceList}`,
    getMainKeyboard()
  );
}

async function handleSubscription(chatId: number, userId: string) {
  const subscription = await getSubscriptionInfo(userId);

  if (subscription) {
    const expiresAt = new Date(subscription.expires_at);
    const now = new Date();
    const daysLeft = Math.ceil((expiresAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    const planNames: Record<string, string> = {
      trial: 'üéÅ –ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥',
      monthly: 'üìÖ –ú–µ—Å—è—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞',
      quarterly: 'üìÜ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ 3 –º–µ—Å—è—Ü–∞',
      yearly: 'üìä –ì–æ–¥–æ–≤–∞—è –ø–æ–¥–ø–∏—Å–∫–∞'
    };

    const keyboard = {
      inline_keyboard: [
        [{ text: 'üîÑ –ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É', callback_data: 'sub_renew' }],
        [{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'sub_back' }]
      ]
    };

    await sendTelegramMessage(
      chatId,
      `üíé <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ</b>\n\n` +
      `${planNames[subscription.plan_type] || subscription.plan_type}\n` +
      `–°—Ç–∞—Ç—É—Å: ${daysLeft > 0 ? '‚úÖ –ê–∫—Ç–∏–≤–Ω–∞' : '‚ùå –ò—Å—Ç–µ–∫–ª–∞'}\n` +
      `–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: ${expiresAt.toLocaleDateString('ru-RU')}\n` +
      `–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π: ${daysLeft}\n\n` +
      `<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n` +
      `‚úÖ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ–∫–æ–≤\n` +
      `‚úÖ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è\n` +
      `‚úÖ –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ`,
      keyboard
    );
  } else {
    const keyboard = {
      inline_keyboard: [
        [{ text: 'üí≥ –ú–µ—Å—è—Ü - 99‚ÇΩ', callback_data: 'sub_monthly' }],
        [{ text: 'üí≥ 3 –º–µ—Å—è—Ü–∞ - 256‚ÇΩ (–≤—ã–≥–æ–¥–∞ 13%)', callback_data: 'sub_quarterly' }],
        [{ text: 'üí≥ –ì–æ–¥ - 1200‚ÇΩ (–≤—ã–≥–æ–¥–∞ 33%)', callback_data: 'sub_yearly' }],
        [{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'sub_back' }]
      ]
    };

    await sendTelegramMessage(
      chatId,
      `üíé <b>–ü—Ä–µ–º–∏—É–º –ø–æ–¥–ø–∏—Å–∫–∞</b>\n\n` +
      `–ü–æ–ª—É—á–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫:\n` +
      `‚úÖ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é —á–µ–∫–æ–≤ —Å AI\n` +
      `‚úÖ –ì–æ–ª–æ—Å–æ–≤—ã–º —Å–æ–æ–±—â–µ–Ω–∏—è–º\n` +
      `‚úÖ –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–º—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é\n\n` +
      `<b>–ü–ª–∞–Ω—ã –ø–æ–¥–ø–∏—Å–∫–∏:</b>\n` +
      `üí≥ <b>–ú–µ—Å—è—Ü</b> - 99‚ÇΩ\n` +
      `üí≥ <b>3 –º–µ—Å—è—Ü–∞</b> - 256‚ÇΩ (–≤—ã–≥–æ–¥–∞ 13%)\n` +
      `üí≥ <b>–ì–æ–¥</b> - 1200‚ÇΩ (–≤—ã–≥–æ–¥–∞ 33%)\n\n` +
      `üéÅ <b>–ù–æ–≤—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º 5 –¥–Ω–µ–π –±–µ—Å–ø–ª–∞—Ç–Ω–æ!</b>\n\n` +
      `–í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–∞–Ω –ø–æ–¥–ø–∏—Å–∫–∏:`,
      keyboard
    );
  }
}

async function startAddExpense(chatId: number, userId: string) {
  console.log(`startAddExpense called for user ${userId}`);

  try {
    const { data: categories, error } = await supabase
      .from('categories')
      .select('id, name, icon')
      .eq('user_id', userId)
      .order('name')
      .limit(10);

    console.log(`Categories query result: ${categories?.length || 0} categories, error: ${error?.message || 'none'}`);

    if (error) {
      console.error('Error fetching categories:', error);
      await sendTelegramMessage(
        chatId,
        '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
        getMainKeyboard()
      );
      return;
    }

    if (!categories || categories.length === 0) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ä–∞—Å—Ö–æ–¥–æ–≤.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget.',
        getMainKeyboard()
      );
      return;
    }

    // Create inline keyboard with categories
    const keyboard = {
      inline_keyboard: categories.map(cat => [{
        text: `${cat.icon} ${cat.name}`,
        callback_data: `exp_cat_${cat.id}`
      }])
    };

    console.log(`Sending expense keyboard with ${categories.length} categories`);
    await sendTelegramMessage(
      chatId,
      'üí∏ <b>–î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:',
      keyboard
    );
  } catch (err) {
    console.error('Exception in startAddExpense:', err);
    await sendTelegramMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
      getMainKeyboard()
    );
  }
}

async function startAddIncome(chatId: number, userId: string) {
  console.log(`startAddIncome called for user ${userId}`);

  try {
    const { data: sources, error } = await supabase
      .from('income_sources')
      .select('id, name')
      .eq('user_id', userId)
      .order('name')
      .limit(10);

    console.log(`Sources query result: ${sources?.length || 0} sources, error: ${error?.message || 'none'}`);

    if (error) {
      console.error('Error fetching sources:', error);
      await sendTelegramMessage(
        chatId,
        '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–æ—Ö–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
        getMainKeyboard()
      );
      return;
    }

    if (!sources || sources.length === 0) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–æ—Ö–æ–¥–∞.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget.',
        getMainKeyboard()
      );
      return;
    }

    // Create inline keyboard with sources
    const keyboard = {
      inline_keyboard: sources.map(src => [{
        text: `üíµ ${src.name}`,
        callback_data: `inc_src_${src.id}`
      }])
    };

    console.log(`Sending income keyboard with ${sources.length} sources`);
    await sendTelegramMessage(
      chatId,
      'üí∞ <b>–î–æ–±–∞–≤–∏—Ç—å –¥–æ—Ö–æ–¥</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å—Ç–æ—á–Ω–∏–∫:',
      keyboard
    );
  } catch (err) {
    console.error('Exception in startAddIncome:', err);
    await sendTelegramMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
      getMainKeyboard()
    );
  }
}

async function handleCallbackQuery(query: CallbackQuery) {
  const chatId = query.message!.chat.id;
  const telegramId = query.from.id;
  const data = query.data!;

  console.log(`handleCallbackQuery: data="${data}", telegramId=${telegramId}`);

  const userId = await getUserByTelegramId(telegramId);
  console.log(`User ID from telegram: ${userId || 'not found'}`);

  if (!userId) {
    // answerCallbackQuery —É–∂–µ –≤—ã–∑–≤–∞–Ω –≤ main handler
    await sendTelegramMessage(chatId, '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start');
    return;
  }

  // Get user currency
  const currency = await getUserCurrency(userId);

  // Handle expense category selection
  if (data.startsWith('exp_cat_')) {
    console.log(`Handling expense category selection`);
    const categoryId = data.replace('exp_cat_', '');
    console.log(`Category ID: ${categoryId}`);

    await setSession(telegramId, { type: 'expense', categoryId });
    console.log(`Session set for expense with category ${categoryId}`);

    await sendTelegramMessage(
      chatId,
      'üí∏ –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Ä–∞—Å—Ö–æ–¥–∞:\n\n–ù–∞–ø—Ä–∏–º–µ—Ä: <code>500</code> –∏–ª–∏ <code>1500 –ü–æ–∫—É–ø–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤</code>\n\n–ù–∞–∂–º–∏—Ç–µ <b>üîô –ù–∞–∑–∞–¥</b>, —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å'
    );
    return;
  }

  // Handle income source selection
  if (data.startsWith('inc_src_')) {
    console.log(`Handling income source selection`);
    const sourceId = data.replace('inc_src_', '');
    console.log(`Source ID: ${sourceId}`);

    await setSession(telegramId, { type: 'income', sourceId });
    console.log(`Session set for income with source ${sourceId}`);

    await sendTelegramMessage(
      chatId,
      'üí∞ –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –¥–æ—Ö–æ–¥–∞:\n\n–ù–∞–ø—Ä–∏–º–µ—Ä: <code>50000</code> –∏–ª–∏ <code>50000 –ó–∞—Ä–ø–ª–∞—Ç–∞ –∑–∞ –æ–∫—Ç—è–±—Ä—å</code>\n\n–ù–∞–∂–º–∏—Ç–µ <b>üîô –ù–∞–∑–∞–¥</b>, —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å'
    );
    return;
  }

  // Handle receipt category confirmation
  if (data.startsWith('receipt_cat_')) {
    console.log(`Receipt category confirmation: categoryId from callback`);
    const categoryId = data.replace('receipt_cat_', '');

    // Get session with receipt data
    const session = await getSession(telegramId);
    console.log(`Session retrieved: ${JSON.stringify(session)}`);

    if (!session || session.type !== 'receipt_confirmation') {
      console.log('Session invalid or expired');
      await sendTelegramMessage(chatId, '‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–µ–∫ –∑–∞–Ω–æ–≤–æ.');
      return;
    }

    const receiptData = session.receiptData;
    console.log(`Receipt data: amount=${receiptData.amount}, store=${receiptData.store}`);

    // Get category info
    const { data: categoryData, error: catError } = await supabase
      .from('categories')
      .select('name, icon')
      .eq('id', categoryId)
      .single();

    console.log(`Category data: ${categoryData ? categoryData.name : 'not found'}, error: ${catError?.message || 'none'}`);

    if (catError || !categoryData) {
      await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏');
      return;
    }

    // Create expense with proper date format
    let expenseDate: string;
    if (receiptData.date) {
      // If date is in YYYY-MM-DD format, convert to full ISO timestamp
      if (receiptData.date.length === 10) {
        expenseDate = new Date(receiptData.date + 'T12:00:00.000Z').toISOString();
      } else {
        expenseDate = new Date(receiptData.date).toISOString();
      }
    } else {
      expenseDate = new Date().toISOString();
    }

    console.log(`Creating expense: userId=${userId}, categoryId=${categoryId}, amount=${receiptData.amount}, date=${expenseDate}, originalDate=${receiptData.date}`);

    const { data: insertedExpense, error } = await supabase
      .from('expenses')
      .insert({
        user_id: userId,
        category_id: categoryId,
        amount: convertToRubles(receiptData.amount, currency),
        description: receiptData.description || receiptData.store,
        date: expenseDate,
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating expense:', error);
      await sendTelegramMessage(
        chatId,
        `‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–∞—Å—Ö–æ–¥–∞: ${error.message}`,
        getMainKeyboard()
      );
      return;
    }

    console.log('Expense created successfully:', JSON.stringify(insertedExpense));

    // Clear session
    await deleteSession(telegramId);

    await sendTelegramMessage(
      chatId,
      `‚úÖ <b>–ß–µ–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!</b>\n\n` +
      `üí∏ –°—É–º–º–∞: <b>${formatAmount(receiptData.amount, currency)}</b>\n` +
      `üìÅ ${categoryData.icon} ${categoryData.name}\n` +
      `üè™ ${receiptData.store}\n` +
      (receiptData.description ? `üìù ${receiptData.description}` : ''),
      getMainKeyboard()
    );
    return;
  }

  // Handle voice expense confirmation
  if (data.startsWith('voice_exp_')) {
    const categoryId = data.replace('voice_exp_', '');
    const session = await getSession(telegramId);

    if (!session || session.type !== 'voice_expense_confirmation') {
      await sendTelegramMessage(chatId, '‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞');
      return;
    }

    // Get category info
    const { data: categoryData, error: catError } = await supabase
      .from('categories')
      .select('name, icon')
      .eq('id', categoryId)
      .single();

    if (catError || !categoryData) {
      await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏');
      return;
    }

    // Create expense
    const { error } = await supabase
      .from('expenses')
      .insert({
        user_id: userId,
        category_id: categoryId,
        amount: convertToRubles(session.amount, currency),
        description: session.description,
        date: new Date().toISOString(),
      });

    if (error) {
      console.error('Error creating voice expense:', error);
      await sendTelegramMessage(chatId, `‚ùå –û—à–∏–±–∫–∞: ${error.message}`);
      return;
    }

    await deleteSession(telegramId);

    await sendTelegramMessage(
      chatId,
      `‚úÖ <b>–†–∞—Å—Ö–æ–¥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!</b>\n\n` +
      `üé§ "${session.transcribedText}"\n\n` +
      `üí∏ –°—É–º–º–∞: <b>${formatAmount(session.amount, currency)}</b>\n` +
      `üìÅ ${categoryData.icon} ${categoryData.name}\n` +
      (session.description ? `üìù ${session.description}` : ''),
      getMainKeyboard()
    );
    return;
  }

  // Handle voice income confirmation
  if (data.startsWith('voice_inc_')) {
    const sourceId = data.replace('voice_inc_', '');
    const session = await getSession(telegramId);

    if (!session || session.type !== 'voice_income_confirmation') {
      await sendTelegramMessage(chatId, '‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞');
      return;
    }

    // Get source info
    const { data: sourceData, error: srcError } = await supabase
      .from('income_sources')
      .select('name')
      .eq('id', sourceId)
      .single();

    if (srcError || !sourceData) {
      await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞');
      return;
    }

    // Create income
    const { error } = await supabase
      .from('incomes')
      .insert({
        user_id: userId,
        source_id: sourceId,
        amount: convertToRubles(session.amount, currency),
        description: session.description,
        date: new Date().toISOString(),
      });

    if (error) {
      console.error('Error creating voice income:', error);
      await sendTelegramMessage(chatId, `‚ùå –û—à–∏–±–∫–∞: ${error.message}`);
      return;
    }

    await deleteSession(telegramId);

    await sendTelegramMessage(
      chatId,
      `‚úÖ <b>–î–æ—Ö–æ–¥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!</b>\n\n` +
      `üé§ "${session.transcribedText}"\n\n` +
      `üí∞ –°—É–º–º–∞: <b>${formatAmount(session.amount, currency)}</b>\n` +
      `üíµ ${sourceData.name}\n` +
      (session.description ? `üìù ${session.description}` : ''),
      getMainKeyboard()
    );
    return;
  }

  // Handle voice cancellation
  if (data === 'voice_cancel') {
    await deleteSession(telegramId);
    await sendTelegramMessage(
      chatId,
      '‚ùå –ì–æ–ª–æ—Å–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞',
      getMainKeyboard()
    );
    return;
  }

  // Handle subscription callbacks
  if (data.startsWith('sub_')) {
    console.log(`Subscription callback: ${data}`);
    await sendTelegramMessage(chatId, '–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ');
    return;
  }

  // Currency menu back -> return to settings
  if (data === 'currency_back') {
    await sendTelegramMessage(
      chatId,
      '‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:',
      getSettingsKeyboard()
    );
    return;
  }

  // Handle currency selection
  if (data.startsWith('currency_')) {
    const newCurrency = data.replace('currency_', '');
    const valid = ['RUB','USD','EUR','GBP','JPY','CNY','KRW','GEL','AMD'].includes(newCurrency);
    if (!valid) {
      await sendTelegramMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –≤–∞–ª—é—Ç—ã');
      return;
    }

    // Try robust save: upsert -> update -> insert
    let saveError: any = null;
    try {
      const { data: upsertRow, error } = await supabase
        .from('user_preferences')
        .upsert({ user_id: userId, currency: newCurrency }, { onConflict: 'user_id' })
        .select()
        .single();
      saveError = error || null;
      if (!saveError) {
        await sendTelegramMessage(
          chatId,
          `‚úÖ –í–∞–ª—é—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: <b>${newCurrency}</b>`
        );
        return;
      }
    } catch (e) {
      saveError = e;
    }

    if (saveError) {
      console.warn('Upsert failed, try update then insert', saveError);
      // Try update
      const { error: updateError } = await supabase
        .from('user_preferences')
        .update({ currency: newCurrency })
        .eq('user_id', userId);
      if (!updateError) {
        await sendTelegramMessage(
          chatId,
          `‚úÖ –í–∞–ª—é—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: <b>${newCurrency}</b>`
        );
        return;
      }
      // Try insert
      const { error: insertError } = await supabase
        .from('user_preferences')
        .insert({ user_id: userId, currency: newCurrency });
      if (!insertError) {
        await sendTelegramMessage(
          chatId,
          `‚úÖ –í–∞–ª—é—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: <b>${newCurrency}</b>`
        );
        return;
      }

      console.error('Error saving currency (insert):', insertError);
      await sendTelegramMessage(chatId, `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∞–ª—é—Ç—É. ${insertError?.message ? '–û—à–∏–±–∫–∞: ' + insertError.message : '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'}`);
      return;
    }
  }

  // Unknown callback data
  console.log(`Unknown callback data: ${data}`);
  await sendTelegramMessage(chatId, '‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞');
}

async function handleTextMessage(message: TelegramMessage, userId: string) {
  const chatId = message.chat.id;
  const telegramId = message.from.id;
  const text = message.text!.trim();

  console.log(`handleTextMessage: text="${text}", userId=${userId}`);

  // Get user currency
  const currency = await getUserCurrency(userId);

  // Check if user is in a session (adding expense/income)
  const session = await getSession(telegramId);
  console.log(`Session state: ${session ? JSON.stringify(session) : 'none'}`);

  if (session) {
    // Allow cancel
    if (text === 'üîô –ù–∞–∑–∞–¥' || text === '/cancel') {
      await deleteSession(telegramId);
      await sendTelegramMessage(
        chatId,
        '‚ùå –í–≤–æ–¥ —Å—É–º–º—ã –æ—Ç–º–µ–Ω–µ–Ω',
        getMainKeyboard()
      );
      return;
    }

    const parts = text.split(' ');
    const amount = parseFloat(parts[0]);

    if (isNaN(amount) || amount <= 0) {
      await sendTelegramMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞. –í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ <b>üîô –ù–∞–∑–∞–¥</b> –¥–ª—è –æ—Ç–º–µ–Ω—ã.');
      return;
    }

    const description = parts.slice(1).join(' ') || null;

    if (session.type === 'expense') {
      const { error } = await supabase
        .from('expenses')
        .insert({
          user_id: userId,
          amount: convertToRubles(amount, currency),
          category_id: session.categoryId,
          description: description,
          date: new Date().toISOString(),
        });

      if (error) {
        await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–∞—Å—Ö–æ–¥–∞.');
      } else {
        await sendTelegramMessage(
          chatId,
          `‚úÖ <b>–†–∞—Å—Ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n` +
          `üí∏ –°—É–º–º–∞: <b>${formatAmount(amount, currency)}</b>\n` +
          (description ? `üìù ${description}` : ''),
          getMainKeyboard()
        );
      }
    } else if (session.type === 'income') {
      const { error } = await supabase
        .from('incomes')
        .insert({
          user_id: userId,
          amount: convertToRubles(amount, currency),
          source_id: session.sourceId,
          description: description,
          date: new Date().toISOString(),
        });

      if (error) {
        await sendTelegramMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–æ—Ö–æ–¥–∞.');
      } else {
        await sendTelegramMessage(
          chatId,
          `‚úÖ <b>–î–æ—Ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n` +
          `üí∞ –°—É–º–º–∞: <b>${formatAmount(amount, currency)}</b>\n` +
          (description ? `üìù ${description}` : ''),
          getMainKeyboard()
        );
      }
    }

    await deleteSession(telegramId);
    return;
  }

  // Handle button presses
  switch (text) {
    case 'üîô –ù–∞–∑–∞–¥':
      await sendTelegramMessage(
        chatId,
        'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é',
        getMainKeyboard()
      );
      break;
    case 'üí∞ –§–∏–Ω–∞–Ω—Å—ã':
      await sendTelegramMessage(
        chatId,
        'üí∞ <b>–§–∏–Ω–∞–Ω—Å—ã</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:',
        getFinanceKeyboard()
      );
      break;
    case 'üìä –û—Ç—á—ë—Ç—ã':
      await sendTelegramMessage(
        chatId,
        'üìä <b>–û—Ç—á—ë—Ç—ã –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:',
        getReportsKeyboard()
      );
      break;
    case '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏':
      await sendTelegramMessage(
        chatId,
        '‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>\n\n' +
        '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–º –∏ –ø–æ–¥–ø–∏—Å–∫–æ–π.\n\n' +
        '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:',
        getSettingsKeyboard()
      );
      break;
    case 'üåç –í–∞–ª—é—Ç–∞':
      await sendTelegramMessage(
        chatId,
        'üåç <b>–í—ã–±–æ—Ä –≤–∞–ª—é—Ç—ã</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—É—é –≤–∞–ª—é—Ç—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—É–º–º:',
        getCurrencyKeyboard()
      );
      break;
    case 'üí∏ –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥':
      await startAddExpense(chatId, userId);
      break;
    case 'üí∞ –î–æ–±–∞–≤–∏—Ç—å –¥–æ—Ö–æ–¥':
      await startAddIncome(chatId, userId);
      break;
    case 'üìä –ë–∞–ª–∞–Ω—Å':
      await handleBalance(chatId, userId);
      break;
    case 'üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏':
      await handleCategories(chatId, userId);
      break;
    case 'üíµ –ò—Å—Ç–æ—á–Ω–∏–∫–∏':
      await handleSources(chatId, userId);
      break;
    case 'üì∏ –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —á–µ–∫':
      await sendTelegramMessage(
        chatId,
        'üì∏ <b>–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ–∫–∞</b>\n\n' +
        '–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞, –∏ —è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:\n' +
        '‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞—é —Å—É–º–º—É\n' +
        '‚úÖ –û–ø—Ä–µ–¥–µ–ª—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é\n' +
        '‚úÖ –°–æ–∑–¥–∞–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é\n\n' +
        'üì∑ –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —á–µ–∫–∞ –≤ —á–∞—Ç!',
        getFinanceKeyboard()
      );
      break;
    case '‚ùì –ü–æ–º–æ—â—å':
      await sendTelegramMessage(
        chatId,
        `üì± <b>CrystalBudget Bot</b>\n\n` +
        `<b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:</b>\n\n` +
        `üí∞ <b>–§–∏–Ω–∞–Ω—Å—ã</b> - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—Ö–æ–¥–∞–º–∏ –∏ —Ä–∞—Å—Ö–æ–¥–∞–º–∏\n` +
        `  ‚Ä¢ –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥/–¥–æ—Ö–æ–¥\n` +
        `  ‚Ä¢ –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —á–µ–∫\n` +
        `  ‚Ä¢ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è\n\n` +
        `üìä <b>–û—Ç—á—ë—Ç—ã</b> - –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n` +
        `  ‚Ä¢ –ë–∞–ª–∞–Ω—Å\n` +
        `  ‚Ä¢ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∏\n\n` +
        `‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>\n` +
        `  ‚Ä¢ ‚ùì –ü–æ–º–æ—â—å\n` +
        `  ‚Ä¢ üåç –í–∞–ª—é—Ç–∞\n\n` +
        `üí° <b>–°–æ–≤–µ—Ç:</b> –ó–∞–ø–∏—à–∏—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ "–ö—É–ø–∏–ª –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –Ω–∞ 500 —Ä—É–±–ª–µ–π" –∏ –±–æ—Ç —Å–æ–∑–¥–∞—Å—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!`,
        getSettingsKeyboard()
      );
      break;
    default:
      await sendTelegramMessage(
        chatId,
        '‚ùì –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É /help',
        getMainKeyboard()
      );
  }
}

async function handleVoiceMessage(message: TelegramMessage, userId: string) {
  const chatId = message.chat.id;
  const telegramId = message.from.id;

  console.log('Voice message received, processing...');

  // Get user currency
  const currency = await getUserCurrency(userId);

  await sendTelegramMessage(chatId, 'üé§ –†–∞—Å–ø–æ–∑–Ω–∞—é –≥–æ–ª–æ—Å...');

  try {
    // Get voice file
    const voice = message.voice!;

    // Get file path from Telegram
    const fileResponse = await fetch(
      `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/getFile?file_id=${voice.file_id}`
    );
    const fileData = await fileResponse.json();

    if (!fileData.ok) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
    }

    const filePath = fileData.result.file_path;
    const fileUrl = `https://api.telegram.org/file/bot${TELEGRAM_BOT_TOKEN}/${filePath}`;

    // Get user's categories and income sources
    const [categoriesRes, sourcesRes] = await Promise.all([
      supabase.from('categories').select('id, name, icon').eq('user_id', userId).order('name'),
      supabase.from('income_sources').select('id, name').eq('user_id', userId).order('name'),
    ]);

    const categories = categoriesRes.data || [];
    const sources = sourcesRes.data || [];

    if (categories.length === 0 && sources.length === 0) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget —Å–Ω–∞—á–∞–ª–∞.',
        getMainKeyboard()
      );
      return;
    }

    // Call transcribe-voice function
    const transcribeResponse = await fetch(
      `${SUPABASE_URL}/functions/v1/transcribe-voice`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
        },
        body: JSON.stringify({
          userId: userId,
          audioUrl: fileUrl,
          categories: categories,
          sources: sources,
        }),
      }
    );

    if (!transcribeResponse.ok) {
      throw new Error('–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞');
    }

    const voiceData = await transcribeResponse.json();

    if (voiceData.error) {
      throw new Error(voiceData.error);
    }

    console.log('Voice data:', voiceData);

    // Handle expense
    if (voiceData.type === 'expense') {
      // Try to find suggested category (optional)
      const suggestedCategory = categories.find(
        (cat: any) => cat.name.toLowerCase().includes(voiceData.category.toLowerCase()) ||
                      voiceData.category.toLowerCase().includes(cat.name.toLowerCase())
      );

      // Store in session for confirmation
      await setSession(telegramId, {
        type: 'voice_expense_confirmation',
        amount: convertToRubles(voiceData.amount, currency),
        description: voiceData.description,
        transcribedText: voiceData.transcribedText,
        suggestedCategory: voiceData.category,
      });

      // Sort categories: suggested first, then alphabetically
      const sortedCategories = [...categories].sort((a: any, b: any) => {
        if (suggestedCategory) {
          if (a.id === suggestedCategory.id) return -1;
          if (b.id === suggestedCategory.id) return 1;
        }
        return a.name.localeCompare(b.name);
      });

      // Show all categories (up to 10)
      const keyboard = {
        inline_keyboard: [
          ...sortedCategories.slice(0, 10).map((cat: any) => [{
            text: `${cat.icon} ${cat.name}${suggestedCategory?.id === cat.id ? ' ‚úÖ' : ''}`,
            callback_data: `voice_exp_${cat.id}`
          }]),
          [{ text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: 'voice_cancel' }]
        ]
      };

      await sendTelegramMessage(
        chatId,
        `üé§ <b>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ:</b> "${voiceData.transcribedText}"\n\n` +
        `üí∏ –°—É–º–º–∞: <b>${formatAmount(voiceData.amount, currency)}</b>\n` +
        (voiceData.description ? `üìù ${voiceData.description}\n` : '') +
        (suggestedCategory ? `\nüí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${suggestedCategory.icon} ${suggestedCategory.name}` : '') +
        `\n\n<b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:</b>`,
        keyboard
      );
    }
    // Handle income
    else if (voiceData.type === 'income') {
      // Try to find suggested source (optional)
      const suggestedSource = sources.find(
        (src: any) => src.name.toLowerCase().includes(voiceData.category.toLowerCase()) ||
                      voiceData.category.toLowerCase().includes(src.name.toLowerCase())
      );

      // Store in session for confirmation
      await setSession(telegramId, {
        type: 'voice_income_confirmation',
        amount: convertToRubles(voiceData.amount, currency),
        description: voiceData.description,
        transcribedText: voiceData.transcribedText,
        suggestedSource: voiceData.category,
      });

      // Sort sources: suggested first, then alphabetically
      const sortedSources = [...sources].sort((a: any, b: any) => {
        if (suggestedSource) {
          if (a.id === suggestedSource.id) return -1;
          if (b.id === suggestedSource.id) return 1;
        }
        return a.name.localeCompare(b.name);
      });

      // Show all sources (up to 10)
      const keyboard = {
        inline_keyboard: [
          ...sortedSources.slice(0, 10).map((src: any) => [{
            text: `üíµ ${src.name}${suggestedSource?.id === src.id ? ' ‚úÖ' : ''}`,
            callback_data: `voice_inc_${src.id}`
          }]),
          [{ text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: 'voice_cancel' }]
        ]
      };

      await sendTelegramMessage(
        chatId,
        `üé§ <b>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ:</b> "${voiceData.transcribedText}"\n\n` +
        `üí∞ –°—É–º–º–∞: <b>${formatAmount(voiceData.amount, currency)}</b>\n` +
        (voiceData.description ? `üìù ${voiceData.description}\n` : '') +
        (suggestedSource ? `\nüí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫: ${suggestedSource.name}` : '') +
        `\n\n<b>–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å—Ç–æ—á–Ω–∏–∫:</b>`,
        keyboard
      );
    }

  } catch (error: any) {
    console.error('Voice processing error:', error);
    await sendTelegramMessage(
      chatId,
      `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n` +
      `–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n` +
      `‚Ä¢ –ì–æ–≤–æ—Ä–∏—Ç—å —á—ë—Ç—á–µ\n` +
      `‚Ä¢ –£–∫–∞–∑–∞—Ç—å —Å—É–º–º—É –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é\n` +
      `‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞`,
      getMainKeyboard()
    );
  }
}

async function handlePhotoMessage(message: TelegramMessage, userId: string) {
  const chatId = message.chat.id;
  const telegramId = message.from.id;

  console.log('Photo received, processing receipt...');

  // Get user currency
  const currency = await getUserCurrency(userId);

  await sendTelegramMessage(chatId, 'üì∏ –°–∫–∞–Ω–∏—Ä—É—é —á–µ–∫...');

  try {
    // Get the largest photo
    const photo = message.photo![message.photo!.length - 1];

    // Get file path from Telegram
    const fileResponse = await fetch(
      `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/getFile?file_id=${photo.file_id}`
    );
    const fileData = await fileResponse.json();

    if (!fileData.ok) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ç–æ');
    }

    const filePath = fileData.result.file_path;
    const fileUrl = `https://api.telegram.org/file/bot${TELEGRAM_BOT_TOKEN}/${filePath}`;

    // Get user's categories
    const { data: categories } = await supabase
      .from('categories')
      .select('name, icon')
      .eq('user_id', userId);

    if (!categories || categories.length === 0) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ä–∞—Å—Ö–æ–¥–æ–≤.\n\n–°–æ–∑–¥–∞–π—Ç–µ –∏—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ CrystalBudget —Å–Ω–∞—á–∞–ª–∞.',
        getMainKeyboard()
      );
      return;
    }

    // Call scan-receipt function
    const scanResponse = await fetch(
      `${SUPABASE_URL}/functions/v1/scan-receipt`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
        },
        body: JSON.stringify({
          userId: userId,
          imageUrl: fileUrl,
          categories: categories,
        }),
      }
    );

    if (!scanResponse.ok) {
      throw new Error('–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —á–µ–∫–∞');
    }

    const receiptData = await scanResponse.json();

    if (receiptData.error) {
      throw new Error(receiptData.error);
    }

    console.log('Receipt data:', receiptData);

    // Store receipt data in session for confirmation
    await setSession(telegramId, {
      type: 'receipt_confirmation',
      receiptData: receiptData,
    });

    // Get all categories with IDs
    const { data: allCategories } = await supabase
      .from('categories')
      .select('id, name, icon')
      .eq('user_id', userId)
      .order('name');

    if (!allCategories || allCategories.length === 0) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Ä–∞—Å—Ö–æ–¥–æ–≤.',
        getMainKeyboard()
      );
      return;
    }

    // Find suggested category
    const suggestedCategory = allCategories.find(
      (c: any) => c.name.toLowerCase() === receiptData.category.toLowerCase()
    );

    // Create keyboard with all categories, suggested one first
    let sortedCategories = allCategories;
    if (suggestedCategory) {
      sortedCategories = [
        suggestedCategory,
        ...allCategories.filter((c: any) => c.id !== suggestedCategory.id)
      ];
    }

    const keyboard = {
      inline_keyboard: sortedCategories.slice(0, 10).map((cat: any) => [{
        text: `${cat.icon} ${cat.name}${cat.id === suggestedCategory?.id ? ' ‚úÖ' : ''}`,
        callback_data: `receipt_cat_${cat.id}`
      }])
    };

    await sendTelegramMessage(
      chatId,
      `üì∏ <b>–ß–µ–∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω!</b>\n\n` +
      `üí∞ –°—É–º–º–∞: <b>${formatAmount(receiptData.amount, currency)}</b>\n` +
      `üè™ ${receiptData.store}\n` +
      (receiptData.description ? `üìù ${receiptData.description}\n` : '') +
      `\n<b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:</b>`,
      keyboard
    );

  } catch (error) {
    console.error('Error processing receipt:', error);
    await sendTelegramMessage(
      chatId,
      '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —á–µ–∫.\n\n' +
      '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:\n' +
      '‚Ä¢ –°–¥–µ–ª–∞—Ç—å —Ñ–æ—Ç–æ –±–æ–ª–µ–µ —á–µ—Ç–∫–∏–º\n' +
      '‚Ä¢ –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –≤–∏–¥–µ–Ω –≤–µ—Å—å —á–µ–∫\n' +
      '‚Ä¢ –î–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—Ö–æ–¥ –≤—Ä—É—á–Ω—É—é',
      getMainKeyboard()
    );
  }
}

async function handleMessage(update: TelegramUpdate) {
  const message = update.message;
  if (!message) return;

  const chatId = message.chat.id;
  const telegramId = message.from.id;
  const firstName = message.from.first_name;
  const lastName = message.from.last_name;
  const username = message.from.username;

  // Handle photos (receipts)
  if (message.photo) {
    const userId = await getUserByTelegramId(telegramId);
    if (!userId) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–¥–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.'
      );
      return;
    }

    await handlePhotoMessage(message, userId);
    return;
  }

  // Handle voice messages
  if (message.voice) {
    const userId = await getUserByTelegramId(telegramId);
    if (!userId) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–¥–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.'
      );
      return;
    }

    await handleVoiceMessage(message, userId);
    return;
  }

  if (!message.text) return;

  const text = message.text;
  console.log(`Received message from ${telegramId}: ${text}`);

  // Handle commands
  if (text.startsWith('/')) {
    if (text === '/start') {
      await handleStart(chatId, telegramId, firstName, lastName, username);
      return;
    }

    // Check authorization for other commands
    const userId = await getUserByTelegramId(telegramId);
    if (!userId) {
      await sendTelegramMessage(
        chatId,
        '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–¥–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.'
      );
      return;
    }

    if (text === '/balance') {
      await handleBalance(chatId, userId);
    } else if (text === '/help') {
      await sendTelegramMessage(
        chatId,
        `üì± <b>CrystalBudget Bot</b>\n\n` +
        `–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º –∏–ª–∏ –∫–æ–º–∞–Ω–¥—ã:\n\n` +
        `/start - –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n` +
        `/balance - –ø–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å\n` +
        `/help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞`,
        getMainKeyboard()
      );
    }
    return;
  }

  // For non-command messages, check authorization
  const userId = await getUserByTelegramId(telegramId);
  if (!userId) {
    await sendTelegramMessage(
      chatId,
      '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–¥–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.'
    );
    return;
  }

  await handleTextMessage(message, userId);
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  let update: TelegramUpdate;
  try {
    const raw = await req.text();
    console.log('RAW UPDATE:', raw);
    update = JSON.parse(raw);
    console.log('Type:', update.callback_query ? 'callback_query' : update.message ? 'message' : 'other');
  } catch (error) {
    console.error('Failed to parse update:', error);
    return new Response(JSON.stringify({ ok: false }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å —Ç–∞–π–º–∞—É—Ç–æ–º –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏–π
  const handler = (async () => {
    try {
      if (update.callback_query) {
        console.log('üîò callback_query | data:', update.callback_query.data, '| user:', update.callback_query.from.id);

        // –í–ê–ñ–ù–û: –°–Ω–∞—á–∞–ª–∞ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, –ø–æ—Ç–æ–º –≤—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ
        await answerCallbackQuery(update.callback_query.id);

        // –¢–µ–ø–µ—Ä—å –º–æ–∂–µ–º —Å–ø–æ–∫–æ–π–Ω–æ –¥–µ–ª–∞—Ç—å sendMessage –∏ —Ç.–¥.
        await handleCallbackQuery(update.callback_query);
      } else if (update.message) {
        console.log('üí¨ message | text:', update.message.text || '[no text]', '| user:', update.message.from.id);
        await handleMessage(update);
      } else {
        console.log('‚ùì unknown update:', JSON.stringify(update).substring(0, 200));
      }
    } catch (error) {
      console.error('Handler error:', error);
    }
  })();

  // –¢–∞–π–º–∞—É—Ç 8 —Å–µ–∫—É–Ω–¥ - –∑–∞—â–∏—Ç–∞ –æ—Ç –¥–æ–ª–≥–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
  const timeout = new Promise((resolve) =>
    setTimeout(() => {
      console.log('‚è±Ô∏è Handler timeout reached (8s)');
      resolve('timeout');
    }, 8000)
  );

  const result = await Promise.race([handler, timeout]);

  // –í—Å–µ–≥–¥–∞ –±—ã—Å—Ç—Ä—ã–π ACK –¥–ª—è Telegram
  return new Response(JSON.stringify({ ok: true, result: result === 'timeout' ? 'timeout' : 'processed' }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  });
});
